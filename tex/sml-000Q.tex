\begin{node}\label{sml-000Q}%
The evaluation of a \SML\ program amounts to checking a declaration is
well-typed, then evaluating it, and adding it to the list of definitions
\begin{subequations}
\begin{equation}
\infer[\Rule{E-Val}]{\Delta\vdash (\mathtt{val}~id=e);prog\Reduces{k}\Delta,id=v\vdash prog}{\Delta\vdash e\Reduces{k}v
& \Delta\vdash e\esti T & \Delta\vdash v~\Value}
\end{equation}
Functions require a bit more care because we allow recursion. In this
case, we temporarily add a binding for the identifier of the function
when evaluating it:
\begin{equation}
\infer[\Rule{E-Fun}]{\Delta\vdash (\mathtt{fun}~id~p);prog\Reduces{k}\Delta,id=v\vdash prog}{\Delta,id=\mathtt{fn}~p\vdash (\mathtt{fn}~p)\Reduces{k}v
& \Delta\vdash (\mathtt{fn}~p)\esti T\to T' & \Delta\vdash v~\Value}
\end{equation}
\end{subequations}
These correspond to the rules found in the \SML\ definition for
evaluating top-level programs.

Care must be taken because, despite all this, each implementation of
\SML\ has its own way of determining the ``main function'' to be
executed as the program. MLton will allow you to run code wherever you
wish, but Poly/ML requires an entry point --- specifically a function
named \verb|main()|. Chris Cannam observed this difficulty in his blogpost\footnote{\url{https://thebreakfastpost.com/2015/06/10/standard-ml-and-how-im-compiling-it/}}.
\end{node}
