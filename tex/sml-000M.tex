\begin{node}[Pattern matching]\label{sml-000M}%
\SML\ functions can be given in multiple clauses depending on the value
of the argument given. This is known as pattern matching. If the value
\define{matches} the pattern, then that corresponding clause is executed.

For now, there are several possible patterns since we have only
discussed integers, Booleans, tuples, and had an aside on records. Oh,
and functions, we discussed functions.

The simplest pattern is a wildecard, denoted by an underscore ``\verb|_|''.
This is always matched by any argument.

The next simplest pattern is a variable. If matched, it behaves as we
expected in our simplified $\beta$-reduction rule: we temporarily append
to our definitions the variable bound to the value of the function argument.

We could also have ``special constants'' (literals for strings,
characters, integers, Booleans). The argument matches special constant
patterns if they are equal as values.

For tuples, we can form a tuple of patterns and perform pattern matching
component-wise. If all components of the argument passed into the
function match all components of the tuple pattern, then we extend the
definitions temporarily (if necessary) and execute the associated
clause.

We can also annotate patterns with types to clarify what type is
expected, which is done with the esti operator ``$p\esti T$'' for
pattern $p$ expected to be type $T$.

We can also ``preserve'' the argument passed in as a variable, writing
``$x$ \texttt{as} $p$'' which will then match the argument passed in
against the pattern $p$ and, if there is a match, stores the argument as
$x$ in the dictionary of bindings.

As we introduce more complicated types (like lists), we will mention
their pattern matching (if relevant).
\end{node}
